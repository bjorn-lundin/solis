
-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- repo                                              
--                                                   
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with Process_Io, Utils;
with Ada.Strings.Fixed; use Ada.Strings.Fixed;
with Sax.Readers;              use Sax.Readers;
with Input_Sources.File;       use Input_Sources.File;
with Unicode.CES;
with Unicode.Encodings;
with Sax.Attributes;



package body Table_Abets is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  Stm_Delete_With_Check,
  Stm_Update_With_Check  : Sql.Statement_Type;


  -- Primary keys, when several fields
  Stm_Select_I1_Betid,
  Stm_Select_I1_Betid_O,
  Stm_Delete_I1_Betid : Sql.Statement_Type; 

  -- non unique index 
  Stm_Select_Count_I2_Marketid,
  Stm_Select_I2_Marketid,
  Stm_Delete_I2_Marketid,
  Stm_Select_I2_Marketid_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I3_Betwon,
  Stm_Select_I3_Betwon,
  Stm_Delete_I3_Betwon,
  Stm_Select_I3_Betwon_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I4_Powerdays,
  Stm_Select_I4_Powerdays,
  Stm_Delete_I4_Powerdays,
  Stm_Select_I4_Powerdays_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I5_Betplaced,
  Stm_Select_I5_Betplaced,
  Stm_Delete_I5_Betplaced,
  Stm_Select_I5_Betplaced_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I6_Startts,
  Stm_Select_I6_Startts,
  Stm_Delete_I6_Startts,
  Stm_Select_I6_Startts_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I7_Betname,
  Stm_Select_I7_Betname,
  Stm_Delete_I7_Betname,
  Stm_Select_I7_Betname_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I8_Status,
  Stm_Select_I8_Status,
  Stm_Delete_I8_Status,
  Stm_Select_I8_Status_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I9_Reference,
  Stm_Select_I9_Reference,
  Stm_Delete_I9_Reference,
  Stm_Select_I9_Reference_O : Sql.Statement_Type;



  -- Procedures for all DBMS

  -- Procedures for DBMS SQL
  -- Primary key

  function Get(Stm : in Sql.Statement_Type) return Table_Abets.Data_Type is
    Data : Table_Abets.Data_Type;
  begin
    Stm.Get("BETID", Data.Betid);
    Stm.Get("MARKETID", Data.Marketid);
    Stm.Get("BETMODE", Data.Betmode);
    Stm.Get("POWERDAYS", Data.Powerdays);
    Stm.Get("SELECTIONID", Data.Selectionid);
    Stm.Get("REFERENCE", Data.Reference);
    Stm.Get("SIZE", Data.Size);
    Stm.Get("PRICE", Data.Price);
    Stm.Get("SIDE", Data.Side);
    Stm.Get("BETNAME", Data.Betname);
    if not Stm.Is_Null("BETWON") then
      Stm.Get("BETWON", Data.Betwon);
    else
      Data.Betwon :=  False;
    end if;
    Stm.Get("PROFIT", Data.Profit);
    Stm.Get("STATUS", Data.Status);
    Stm.Get("EXESTATUS", Data.Exestatus);
    Stm.Get("EXEERRCODE", Data.Exeerrcode);
    Stm.Get("INSTSTATUS", Data.Inststatus);
    Stm.Get("INSTERRCODE", Data.Insterrcode);
    if not Stm.Is_Null("STARTTS") then
      Stm.Get_Timestamp("STARTTS", Data.Startts);
    else
      Data.Startts :=  Time_Type_First;
    end if;
    if not Stm.Is_Null("BETPLACED") then
      Stm.Get_Timestamp("BETPLACED", Data.Betplaced);
    else
      Data.Betplaced :=  Time_Type_First;
    end if;
    Stm.Get("PRICEMATCHED", Data.Pricematched);
    Stm.Get("SIZEMATCHED", Data.Sizematched);
    Stm.Get("RUNNERNAME", Data.Runnername);
    Stm.Get("FULLMARKETNAME", Data.Fullmarketname);
    Stm.Get("SVNREVISION", Data.Svnrevision);
    Stm.Get("IXXLUPD", Data.Ixxlupd);
    Stm.Get_Timestamp("IXXLUTS", Data.Ixxluts);

    return Data;
  end Get;
---------------------------------------------


  function Get(
                  Betid : Integer_8) return Table_Abets.Data_Type is
    Data       : Table_Abets.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Betid := Betid;
    Data.Read(End_Of_Set);
    return Data;
  end Get;



  procedure Read_All(List  : in out Abets_List_Pack2.List;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans   : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
      Stm_Select_All_O.Prepare("select * from ABETS order by " &
                  "BETID");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Stm_Select_All.Prepare("select * from ABETS");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;
  end Read_All;


  procedure Read_List(Stm   : in     Sql.Statement_Type;
                      List  : in out Abets_List_Pack2.List;
                      Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans  : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction  : Sql.Transaction_Type;
    Count        : Integer_4 := 0;
    Data         : Table_Abets.Data_Type;
    Eos          : Boolean := False;
  begin
    if Start_Trans then Transaction.Start; end if;
    Stm.Open_Cursor;
    loop
      Stm.Fetch(Eos);
      exit when Eos or Count > Max;
      Data := Get(Stm);
      List.Append(Data);
      Count := Count +1;
    end loop;
    Stm.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
  end Read_List;


  function Is_Existing(
                  Betid : Integer_8) return Boolean is
    Data       : Table_Abets.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Betid := Betid;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;


  procedure Read(Data       : in out Table_Abets.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    Stm_Select.Prepare("select * from ABETS " &
                "where BETID =:BETID " &
            "");
    Stm_Select.Set("BETID", Data.Betid);
    Stm_Select.Open_Cursor;
    Stm_Select.Fetch(End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Stm_Select.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
  end Read;

  procedure Delete(Data : in Table_Abets.Data_Type) is
  begin
    Stm_Delete.Prepare("delete from ABETS " &
                "where BETID =:BETID " &
            "");
    Stm_Delete.Set("BETID", Data.Betid);
    Stm_Delete.Execute;
  end Delete;

  procedure Update(Data : in out Table_Abets.Data_Type ; Keep_Timestamp : in Boolean := False) is
    Now     : Calendar2.Time_Type := Calendar2.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Stm_Update.Prepare("update ABETS set  " &
            "MARKETID=:MARKETID, " &
            "BETMODE=:BETMODE, " &
            "POWERDAYS=:POWERDAYS, " &
            "SELECTIONID=:SELECTIONID, " &
            "REFERENCE=:REFERENCE, " &
            "SIZE=:SIZE, " &
            "PRICE=:PRICE, " &
            "SIDE=:SIDE, " &
            "BETNAME=:BETNAME, " &
            "BETWON=:BETWON, " &
            "PROFIT=:PROFIT, " &
            "STATUS=:STATUS, " &
            "EXESTATUS=:EXESTATUS, " &
            "EXEERRCODE=:EXEERRCODE, " &
            "INSTSTATUS=:INSTSTATUS, " &
            "INSTERRCODE=:INSTERRCODE, " &
            "STARTTS=:STARTTS, " &
            "BETPLACED=:BETPLACED, " &
            "PRICEMATCHED=:PRICEMATCHED, " &
            "SIZEMATCHED=:SIZEMATCHED, " &
            "RUNNERNAME=:RUNNERNAME, " &
            "FULLMARKETNAME=:FULLMARKETNAME, " &
            "SVNREVISION=:SVNREVISION, " &
            "IXXLUPD=:IXXLUPD, " &
            "IXXLUTS=:IXXLUTS " &
            "where BETID=:BETID " &
            "");

    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
      Stm_Update.Set("MARKETID", Data.Marketid);
      Stm_Update.Set("BETMODE", Data.Betmode);
      Stm_Update.Set("POWERDAYS", Data.Powerdays);
      Stm_Update.Set("SELECTIONID", Data.Selectionid);
      Stm_Update.Set("REFERENCE", Data.Reference);
      Stm_Update.Set("SIZE", Data.Size);
      Stm_Update.Set("PRICE", Data.Price);
      Stm_Update.Set("SIDE", Data.Side);
      Stm_Update.Set("BETNAME", Data.Betname);
      Stm_Update.Set("BETWON", Data.Betwon);
      Stm_Update.Set("PROFIT", Data.Profit);
      Stm_Update.Set("STATUS", Data.Status);
      Stm_Update.Set("EXESTATUS", Data.Exestatus);
      Stm_Update.Set("EXEERRCODE", Data.Exeerrcode);
      Stm_Update.Set("INSTSTATUS", Data.Inststatus);
      Stm_Update.Set("INSTERRCODE", Data.Insterrcode);
    if Data.Startts = Time_Type_First then
      Stm_Update.Set_Null_Date("STARTTS");
    else
      Stm_Update.Set_Timestamp("STARTTS", Data.Startts);
    end if;
    if Data.Betplaced = Time_Type_First then
      Stm_Update.Set_Null_Date("BETPLACED");
    else
      Stm_Update.Set_Timestamp("BETPLACED", Data.Betplaced);
    end if;
      Stm_Update.Set("PRICEMATCHED", Data.Pricematched);
      Stm_Update.Set("SIZEMATCHED", Data.Sizematched);
      Stm_Update.Set("RUNNERNAME", Data.Runnername);
      Stm_Update.Set("FULLMARKETNAME", Data.Fullmarketname);
      Stm_Update.Set("SVNREVISION", Data.Svnrevision);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name(1..15);
    end if;
      Stm_Update.Set("IXXLUPD", Data.Ixxlupd);
      Stm_Update.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Update.Set("BETID", Data.Betid);
    Stm_Update.Execute;
  end Update;

  procedure Insert(Data : in out Table_Abets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Calendar2.Time_Type := Calendar2.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
    Stm_Insert.Prepare("insert into ABETS values (" &
         ":BETID," &
         ":MARKETID," &
         ":BETMODE," &
         ":POWERDAYS," &
         ":SELECTIONID," &
         ":REFERENCE," &
         ":SIZE," &
         ":PRICE," &
         ":SIDE," &
         ":BETNAME," &
         ":BETWON," &
         ":PROFIT," &
         ":STATUS," &
         ":EXESTATUS," &
         ":EXEERRCODE," &
         ":INSTSTATUS," &
         ":INSTERRCODE," &
         ":STARTTS," &
         ":BETPLACED," &
         ":PRICEMATCHED," &
         ":SIZEMATCHED," &
         ":RUNNERNAME," &
         ":FULLMARKETNAME," &
         ":SVNREVISION," &
         ":IXXLUPD," &
         ":IXXLUTS)");

    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
      Stm_Insert.Set("BETID", Data.Betid);
      Stm_Insert.Set("MARKETID", Data.Marketid);
      Stm_Insert.Set("BETMODE", Data.Betmode);
      Stm_Insert.Set("POWERDAYS", Data.Powerdays);
      Stm_Insert.Set("SELECTIONID", Data.Selectionid);
      Stm_Insert.Set("REFERENCE", Data.Reference);
      Stm_Insert.Set("SIZE", Data.Size);
      Stm_Insert.Set("PRICE", Data.Price);
      Stm_Insert.Set("SIDE", Data.Side);
      Stm_Insert.Set("BETNAME", Data.Betname);
  -- call  Set_Non_Null start boolean
      Stm_Insert.Set("BETWON", Data.Betwon);
  -- call  Set_Non_Null stop boolean
      Stm_Insert.Set("PROFIT", Data.Profit);
      Stm_Insert.Set("STATUS", Data.Status);
      Stm_Insert.Set("EXESTATUS", Data.Exestatus);
      Stm_Insert.Set("EXEERRCODE", Data.Exeerrcode);
      Stm_Insert.Set("INSTSTATUS", Data.Inststatus);
      Stm_Insert.Set("INSTERRCODE", Data.Insterrcode);
  -- call  not boolean
    if Data.Startts = Time_Type_First then
      Stm_Insert.Set_Null_Date("STARTTS");
    else
      Stm_Insert.Set_Timestamp("STARTTS", Data.Startts);
    end if;
  -- call  not boolean
    if Data.Betplaced = Time_Type_First then
      Stm_Insert.Set_Null_Date("BETPLACED");
    else
      Stm_Insert.Set_Timestamp("BETPLACED", Data.Betplaced);
    end if;
      Stm_Insert.Set("PRICEMATCHED", Data.Pricematched);
      Stm_Insert.Set("SIZEMATCHED", Data.Sizematched);
      Stm_Insert.Set("RUNNERNAME", Data.Runnername);
      Stm_Insert.Set("FULLMARKETNAME", Data.Fullmarketname);
      Stm_Insert.Set("SVNREVISION", Data.Svnrevision);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name(1..15);
    end if;
      Stm_Insert.Set("IXXLUPD", Data.Ixxlupd);
      Stm_Insert.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Insert.Execute;
  end Insert;
--------------------------------------------
  procedure Delete_Withcheck(Data : in Table_Abets.Data_Type) is
  begin
    Stm_Delete_With_Check.Prepare("delete from ABETS " &
                "where BETID =:BETID " &
            "and IXXLUPD = :IXXLUPD " &
            "and IXXLUTS = :IXXLUTS " &
            "");
    Stm_Delete_With_Check.Set("BETID", Data.Betid);
    Stm_Delete_With_Check.Set("IXXLUPD", Data.Ixxlupd);
    Stm_Delete_With_Check.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Delete_With_Check.Execute;
  end Delete_Withcheck;
--------------------------------------------
  procedure Update_Withcheck(Data : in out Table_Abets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Calendar2.Time_Type := Calendar2.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Stm_Update_With_Check.Prepare("update ABETS set  " &
            "MARKETID=:MARKETID, " &
            "BETMODE=:BETMODE, " &
            "POWERDAYS=:POWERDAYS, " &
            "SELECTIONID=:SELECTIONID, " &
            "REFERENCE=:REFERENCE, " &
            "SIZE=:SIZE, " &
            "PRICE=:PRICE, " &
            "SIDE=:SIDE, " &
            "BETNAME=:BETNAME, " &
            "BETWON=:BETWON, " &
            "PROFIT=:PROFIT, " &
            "STATUS=:STATUS, " &
            "EXESTATUS=:EXESTATUS, " &
            "EXEERRCODE=:EXEERRCODE, " &
            "INSTSTATUS=:INSTSTATUS, " &
            "INSTERRCODE=:INSTERRCODE, " &
            "STARTTS=:STARTTS, " &
            "BETPLACED=:BETPLACED, " &
            "PRICEMATCHED=:PRICEMATCHED, " &
            "SIZEMATCHED=:SIZEMATCHED, " &
            "RUNNERNAME=:RUNNERNAME, " &
            "FULLMARKETNAME=:FULLMARKETNAME, " &
            "SVNREVISION=:SVNREVISION, " &
            "IXXLUPD=:IXXLUPD, " &
            "IXXLUTS=:IXXLUTS " &
            "where BETID=:BETID " &
    "and IXXLUPD = :OLD_IXXLUPD " &
    "and IXXLUTS = :OLD_IXXLUTS " &
            "");
    Stm_Update_With_Check.Set("BETID", Data.Betid);
    Stm_Update_With_Check.Set("OLD_IXXLUPD", Data.Ixxlupd );
    Stm_Update_With_Check.Set_Timestamp("OLD_IXXLUTS", Data.Ixxluts );

    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
      Stm_Update_With_Check.Set("MARKETID", Data.Marketid);
      Stm_Update_With_Check.Set("BETMODE", Data.Betmode);
      Stm_Update_With_Check.Set("POWERDAYS", Data.Powerdays);
      Stm_Update_With_Check.Set("SELECTIONID", Data.Selectionid);
      Stm_Update_With_Check.Set("REFERENCE", Data.Reference);
      Stm_Update_With_Check.Set("SIZE", Data.Size);
      Stm_Update_With_Check.Set("PRICE", Data.Price);
      Stm_Update_With_Check.Set("SIDE", Data.Side);
      Stm_Update_With_Check.Set("BETNAME", Data.Betname);
      Stm_Update_With_Check.Set("BETWON", Data.Betwon);
      Stm_Update_With_Check.Set("PROFIT", Data.Profit);
      Stm_Update_With_Check.Set("STATUS", Data.Status);
      Stm_Update_With_Check.Set("EXESTATUS", Data.Exestatus);
      Stm_Update_With_Check.Set("EXEERRCODE", Data.Exeerrcode);
      Stm_Update_With_Check.Set("INSTSTATUS", Data.Inststatus);
      Stm_Update_With_Check.Set("INSTERRCODE", Data.Insterrcode);
    if Data.Startts = Time_Type_First then
      Stm_Update_With_Check.Set_Null_Date("STARTTS");
    else
      Stm_Update_With_Check.Set_Timestamp("STARTTS", Data.Startts);
    end if;
    if Data.Betplaced = Time_Type_First then
      Stm_Update_With_Check.Set_Null_Date("BETPLACED");
    else
      Stm_Update_With_Check.Set_Timestamp("BETPLACED", Data.Betplaced);
    end if;
      Stm_Update_With_Check.Set("PRICEMATCHED", Data.Pricematched);
      Stm_Update_With_Check.Set("SIZEMATCHED", Data.Sizematched);
      Stm_Update_With_Check.Set("RUNNERNAME", Data.Runnername);
      Stm_Update_With_Check.Set("FULLMARKETNAME", Data.Fullmarketname);
      Stm_Update_With_Check.Set("SVNREVISION", Data.Svnrevision);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name(1..15);
    end if;
      Stm_Update_With_Check.Set("IXXLUPD", Data.Ixxlupd);
      Stm_Update_With_Check.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Update_With_Check.Execute;
  end Update_Withcheck;
--------------------------------------------
   -- stop Print_Def_Functions_Body.Primary_Procs_Body


  -- non unique index
  procedure Read_One_Marketid(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Marketid(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Marketid;
  --------------------------------------------

  -- non unique index
  function Count_Marketid(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I2_Marketid.Prepare("select count('a') from ABETS " &
                "where MARKETID =:MARKETID " &
            "");
    Stm_Select_Count_I2_Marketid.Set("MARKETID", Data.Marketid);

    Stm_Select_Count_I2_Marketid.Open_Cursor;
    Stm_Select_Count_I2_Marketid.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I2_Marketid.Get(1, Count);
    end if;
    Stm_Select_Count_I2_Marketid.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Marketid;
  --------------------------------------------

  -- non unique index
  procedure Delete_Marketid(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I2_Marketid.Prepare("delete from ABETS " &
                "where MARKETID =:MARKETID " &
            "");
    Stm_Delete_I2_Marketid.Set("MARKETID", Data.Marketid);

    Stm_Delete_I2_Marketid.Execute;
  end Delete_Marketid;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I2(Marketid : in String) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Marketid := Marketid;
    Read_Marketid(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I2;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Betwon(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Betwon(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Betwon;
  --------------------------------------------

  -- non unique index
  function Count_Betwon(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I3_Betwon.Prepare("select count('a') from ABETS " &
                "where BETWON =:BETWON " &
            "");
    Stm_Select_Count_I3_Betwon.Set("BETWON", Data.Betwon);

    Stm_Select_Count_I3_Betwon.Open_Cursor;
    Stm_Select_Count_I3_Betwon.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I3_Betwon.Get(1, Count);
    end if;
    Stm_Select_Count_I3_Betwon.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Betwon;
  --------------------------------------------

  -- non unique index
  procedure Delete_Betwon(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I3_Betwon.Prepare("delete from ABETS " &
                "where BETWON =:BETWON " &
            "");
    Stm_Delete_I3_Betwon.Set("BETWON", Data.Betwon);

    Stm_Delete_I3_Betwon.Execute;
  end Delete_Betwon;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I3(Betwon : in Boolean) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Betwon := Betwon;
    Read_Betwon(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I3;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Powerdays(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Powerdays(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Powerdays;
  --------------------------------------------

  -- non unique index
  function Count_Powerdays(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I4_Powerdays.Prepare("select count('a') from ABETS " &
                "where POWERDAYS =:POWERDAYS " &
            "");
    Stm_Select_Count_I4_Powerdays.Set("POWERDAYS", Data.Powerdays);

    Stm_Select_Count_I4_Powerdays.Open_Cursor;
    Stm_Select_Count_I4_Powerdays.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I4_Powerdays.Get(1, Count);
    end if;
    Stm_Select_Count_I4_Powerdays.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Powerdays;
  --------------------------------------------

  -- non unique index
  procedure Delete_Powerdays(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I4_Powerdays.Prepare("delete from ABETS " &
                "where POWERDAYS =:POWERDAYS " &
            "");
    Stm_Delete_I4_Powerdays.Set("POWERDAYS", Data.Powerdays);

    Stm_Delete_I4_Powerdays.Execute;
  end Delete_Powerdays;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I4(Powerdays : in Integer_4) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Powerdays := Powerdays;
    Read_Powerdays(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I4;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Betplaced(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Betplaced(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Betplaced;
  --------------------------------------------

  -- non unique index
  function Count_Betplaced(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I5_Betplaced.Prepare("select count('a') from ABETS " &
                "where BETPLACED =:BETPLACED " &
            "");
    Stm_Select_Count_I5_Betplaced.Set_Timestamp("BETPLACED", Data.Betplaced);

    Stm_Select_Count_I5_Betplaced.Open_Cursor;
    Stm_Select_Count_I5_Betplaced.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I5_Betplaced.Get(1, Count);
    end if;
    Stm_Select_Count_I5_Betplaced.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Betplaced;
  --------------------------------------------

  -- non unique index
  procedure Delete_Betplaced(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I5_Betplaced.Prepare("delete from ABETS " &
                "where BETPLACED =:BETPLACED " &
            "");
    Stm_Delete_I5_Betplaced.Set_Timestamp("BETPLACED", Data.Betplaced);

    Stm_Delete_I5_Betplaced.Execute;
  end Delete_Betplaced;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I5(Betplaced : in Time_Type) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Betplaced := Betplaced;
    Read_Betplaced(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I5;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Startts(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Startts(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Startts;
  --------------------------------------------

  -- non unique index
  function Count_Startts(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I6_Startts.Prepare("select count('a') from ABETS " &
                "where STARTTS =:STARTTS " &
            "");
    Stm_Select_Count_I6_Startts.Set_Timestamp("STARTTS", Data.Startts);

    Stm_Select_Count_I6_Startts.Open_Cursor;
    Stm_Select_Count_I6_Startts.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I6_Startts.Get(1, Count);
    end if;
    Stm_Select_Count_I6_Startts.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Startts;
  --------------------------------------------

  -- non unique index
  procedure Delete_Startts(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I6_Startts.Prepare("delete from ABETS " &
                "where STARTTS =:STARTTS " &
            "");
    Stm_Delete_I6_Startts.Set_Timestamp("STARTTS", Data.Startts);

    Stm_Delete_I6_Startts.Execute;
  end Delete_Startts;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I6(Startts : in Time_Type) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Startts := Startts;
    Read_Startts(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I6;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Betname(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Betname(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Betname;
  --------------------------------------------

  -- non unique index
  function Count_Betname(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I7_Betname.Prepare("select count('a') from ABETS " &
                "where BETNAME =:BETNAME " &
            "");
    Stm_Select_Count_I7_Betname.Set("BETNAME", Data.Betname);

    Stm_Select_Count_I7_Betname.Open_Cursor;
    Stm_Select_Count_I7_Betname.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I7_Betname.Get(1, Count);
    end if;
    Stm_Select_Count_I7_Betname.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Betname;
  --------------------------------------------

  -- non unique index
  procedure Delete_Betname(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I7_Betname.Prepare("delete from ABETS " &
                "where BETNAME =:BETNAME " &
            "");
    Stm_Delete_I7_Betname.Set("BETNAME", Data.Betname);

    Stm_Delete_I7_Betname.Execute;
  end Delete_Betname;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I7(Betname : in String) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Betname := Betname;
    Read_Betname(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I7;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Status(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Status(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Status;
  --------------------------------------------

  -- non unique index
  function Count_Status(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I8_Status.Prepare("select count('a') from ABETS " &
                "where STATUS =:STATUS " &
            "");
    Stm_Select_Count_I8_Status.Set("STATUS", Data.Status);

    Stm_Select_Count_I8_Status.Open_Cursor;
    Stm_Select_Count_I8_Status.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I8_Status.Get(1, Count);
    end if;
    Stm_Select_Count_I8_Status.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Status;
  --------------------------------------------

  -- non unique index
  procedure Delete_Status(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I8_Status.Prepare("delete from ABETS " &
                "where STATUS =:STATUS " &
            "");
    Stm_Delete_I8_Status.Set("STATUS", Data.Status);

    Stm_Delete_I8_Status.Execute;
  end Delete_Status;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I8(Status : in String) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Status := Status;
    Read_Status(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I8;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Reference(
                           Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack2.List;
  begin
    Data.Read_Reference(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Reference;
  --------------------------------------------

  -- non unique index
  function Count_Reference(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I9_Reference.Prepare("select count('a') from ABETS " &
                "where REFERENCE =:REFERENCE " &
            "");
    Stm_Select_Count_I9_Reference.Set("REFERENCE", Data.Reference);

    Stm_Select_Count_I9_Reference.Open_Cursor;
    Stm_Select_Count_I9_Reference.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I9_Reference.Get(1, Count);
    end if;
    Stm_Select_Count_I9_Reference.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Reference;
  --------------------------------------------

  -- non unique index
  procedure Delete_Reference(Data  : in     Table_Abets.Data_Type) is
  begin

    Stm_Delete_I9_Reference.Prepare("delete from ABETS " &
                "where REFERENCE =:REFERENCE " &
            "");
    Stm_Delete_I9_Reference.Set("REFERENCE", Data.Reference);

    Stm_Delete_I9_Reference.Execute;
  end Delete_Reference;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I9(Reference : in String) return Boolean is
    Data       : Table_Abets.Data_Type;
    Exists     : Boolean := False;
    List       : Abets_List_Pack2.List;
  begin
    Data.Reference := Reference;
    Read_Reference(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I9;
  --------------------------------------------








  -- Procedures for all DBMS


  function To_String(Data : in Table_Abets.Data_Type) return String is
  begin
    return
          "Betid = " & Utils.Trim(Data.Betid'Img) & " " &
          "Marketid = " & Utils.Trim(Data.Marketid) & " " &
          "Betmode = " & Utils.Trim(Data.Betmode'Img) & " " &
          "Powerdays = " & Utils.Trim(Data.Powerdays'Img) & " " &
          "Selectionid = " & Utils.Trim(Data.Selectionid'Img) & " " &
          "Reference = " & Utils.Trim(Data.Reference) & " " &
          "Size = " & Utils.F8_Image(Data.Size) & " " &
          "Price = " & Utils.F8_Image(Data.Price) & " " &
          "Side = " & Utils.Trim(Data.Side) & " " &
          "Betname = " & Utils.Trim(Data.Betname) & " " &
          "Betwon = " & Utils.Trim(Data.Betwon'Img) & " " &
          "Profit = " & Utils.F8_Image(Data.Profit) & " " &
          "Status = " & Utils.Trim(Data.Status) & " " &
          "Exestatus = " & Utils.Trim(Data.Exestatus) & " " &
          "Exeerrcode = " & Utils.Trim(Data.Exeerrcode) & " " &
          "Inststatus = " & Utils.Trim(Data.Inststatus) & " " &
          "Insterrcode = " & Utils.Trim(Data.Insterrcode) & " " &
          "Startts = " & Calendar2.String_Date_And_Time(Data.Startts, Milliseconds => True ) & " " &
          "Betplaced = " & Calendar2.String_Date_And_Time(Data.Betplaced, Milliseconds => True ) & " " &
          "Pricematched = " & Utils.F8_Image(Data.Pricematched) & " " &
          "Sizematched = " & Utils.F8_Image(Data.Sizematched) & " " &
          "Runnername = " & Utils.Trim(Data.Runnername) & " " &
          "Fullmarketname = " & Utils.Trim(Data.Fullmarketname) & " " &
          "Svnrevision = " & Utils.Trim(Data.Svnrevision) & " " &
          "Ixxlupd = " & Utils.Trim(Data.Ixxlupd) & " " &
          "Ixxluts = " & Calendar2.String_Date_And_Time(Data.Ixxluts, Milliseconds => True ) & " " &
          "";
  end To_String;

  function To_JSON(Data : in Table_Abets.Data_Type) return JSON_Value is
    Json_Data : JSON_Value := Create_Object;
  begin
    Json_Data.Set_Field(Field_Name => "betid", Field => Long_Integer(Data.Betid));
    Json_Data.Set_Field(Field_Name => "marketid", Field => Utils.Trim(Data.Marketid));
    Json_Data.Set_Field(Field_Name => "betmode", Field => Long_Integer(Data.Betmode));
    Json_Data.Set_Field(Field_Name => "powerdays", Field => Long_Integer(Data.Powerdays));
    Json_Data.Set_Field(Field_Name => "selectionid", Field => Long_Integer(Data.Selectionid));
    Json_Data.Set_Field(Field_Name => "reference", Field => Utils.Trim(Data.Reference));
    Json_Data.Set_Field(Field_Name => "size", Field => Float(Data.Size));
    Json_Data.Set_Field(Field_Name => "price", Field => Float(Data.Price));
    Json_Data.Set_Field(Field_Name => "side", Field => Utils.Trim(Data.Side));
    Json_Data.Set_Field(Field_Name => "betname", Field => Utils.Trim(Data.Betname));
    Json_Data.Set_Field(Field_Name => "betwon", Field => Data.Betwon);
    Json_Data.Set_Field(Field_Name => "profit", Field => Float(Data.Profit));
    Json_Data.Set_Field(Field_Name => "status", Field => Utils.Trim(Data.Status));
    Json_Data.Set_Field(Field_Name => "exestatus", Field => Utils.Trim(Data.Exestatus));
    Json_Data.Set_Field(Field_Name => "exeerrcode", Field => Utils.Trim(Data.Exeerrcode));
    Json_Data.Set_Field(Field_Name => "inststatus", Field => Utils.Trim(Data.Inststatus));
    Json_Data.Set_Field(Field_Name => "insterrcode", Field => Utils.Trim(Data.Insterrcode));
    Json_Data.Set_Field(Field_Name => "startts", Field => Data.Startts.To_String);
    Json_Data.Set_Field(Field_Name => "betplaced", Field => Data.Betplaced.To_String);
    Json_Data.Set_Field(Field_Name => "pricematched", Field => Float(Data.Pricematched));
    Json_Data.Set_Field(Field_Name => "sizematched", Field => Float(Data.Sizematched));
    Json_Data.Set_Field(Field_Name => "runnername", Field => Utils.Trim(Data.Runnername));
    Json_Data.Set_Field(Field_Name => "fullmarketname", Field => Utils.Trim(Data.Fullmarketname));
    Json_Data.Set_Field(Field_Name => "svnrevision", Field => Utils.Trim(Data.Svnrevision));
    Json_Data.Set_Field(Field_Name => "ixxlupd", Field => Utils.Trim(Data.Ixxlupd));
    Json_Data.Set_Field(Field_Name => "ixxluts", Field => Data.Ixxluts.To_String);
    return Json_Data;
  end To_JSON;

  function From_JSON(JSON_Data : in JSON_Value) return Table_Abets.Data_Type is
    use Ada.Strings;
    Data : Table_Abets.Data_Type;
  begin
    if JSON_Data.Has_Field("betid") then
      declare
        Tmp : Long_Integer := 0;
      begin
        Tmp := JSON_Data.Get("betid");
        Data.Betid := Integer_8(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("marketid") then
      Move( Source => JSON_Data.Get("marketid"), Target => Data.Marketid , Drop => Right);
    end if;

    if JSON_Data.Has_Field("betmode") then
      declare
        Tmp : Long_Integer := 0;
      begin
        Tmp := JSON_Data.Get("betmode");
        Data.Betmode := Integer_4(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("powerdays") then
      declare
        Tmp : Long_Integer := 0;
      begin
        Tmp := JSON_Data.Get("powerdays");
        Data.Powerdays := Integer_4(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("selectionid") then
      declare
        Tmp : Long_Integer := 0;
      begin
        Tmp := JSON_Data.Get("selectionid");
        Data.Selectionid := Integer_4(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("reference") then
      Move( Source => JSON_Data.Get("reference"), Target => Data.Reference , Drop => Right);
    end if;

    if JSON_Data.Has_Field("size") then
      declare
        Tmp : Float := 0.0;
      begin
        Tmp := JSON_Data.Get("size");
        Data.Size := Fixed_Type(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("price") then
      declare
        Tmp : Float := 0.0;
      begin
        Tmp := JSON_Data.Get("price");
        Data.Price := Fixed_Type(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("side") then
      Move( Source => JSON_Data.Get("side"), Target => Data.Side , Drop => Right);
    end if;

    if JSON_Data.Has_Field("betname") then
      Move( Source => JSON_Data.Get("betname"), Target => Data.Betname , Drop => Right);
    end if;

    if JSON_Data.Has_Field("betwon") then
        Data.Betwon := JSON_Data.Get("betwon");
    end if;

    if JSON_Data.Has_Field("profit") then
      declare
        Tmp : Float := 0.0;
      begin
        Tmp := JSON_Data.Get("profit");
        Data.Profit := Fixed_Type(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("status") then
      Move( Source => JSON_Data.Get("status"), Target => Data.Status , Drop => Right);
    end if;

    if JSON_Data.Has_Field("exestatus") then
      Move( Source => JSON_Data.Get("exestatus"), Target => Data.Exestatus , Drop => Right);
    end if;

    if JSON_Data.Has_Field("exeerrcode") then
      Move( Source => JSON_Data.Get("exeerrcode"), Target => Data.Exeerrcode , Drop => Right);
    end if;

    if JSON_Data.Has_Field("inststatus") then
      Move( Source => JSON_Data.Get("inststatus"), Target => Data.Inststatus , Drop => Right);
    end if;

    if JSON_Data.Has_Field("insterrcode") then
      Move( Source => JSON_Data.Get("insterrcode"), Target => Data.Insterrcode , Drop => Right);
    end if;

    if JSON_Data.Has_Field("startts") then
      declare
        Tmp : String := JSON_Data.Get("startts");
      begin  -- "marketStartTime":"2013-06-22T17:39:00.000Z"
        Data.Startts := Calendar2.To_Time_Type(Tmp(1..10), Tmp(12..23));
      end;
    end if;

    if JSON_Data.Has_Field("betplaced") then
      declare
        Tmp : String := JSON_Data.Get("betplaced");
      begin  -- "marketStartTime":"2013-06-22T17:39:00.000Z"
        Data.Betplaced := Calendar2.To_Time_Type(Tmp(1..10), Tmp(12..23));
      end;
    end if;

    if JSON_Data.Has_Field("pricematched") then
      declare
        Tmp : Float := 0.0;
      begin
        Tmp := JSON_Data.Get("pricematched");
        Data.Pricematched := Fixed_Type(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("sizematched") then
      declare
        Tmp : Float := 0.0;
      begin
        Tmp := JSON_Data.Get("sizematched");
        Data.Sizematched := Fixed_Type(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("runnername") then
      Move( Source => JSON_Data.Get("runnername"), Target => Data.Runnername , Drop => Right);
    end if;

    if JSON_Data.Has_Field("fullmarketname") then
      Move( Source => JSON_Data.Get("fullmarketname"), Target => Data.Fullmarketname , Drop => Right);
    end if;

    if JSON_Data.Has_Field("svnrevision") then
      Move( Source => JSON_Data.Get("svnrevision"), Target => Data.Svnrevision , Drop => Right);
    end if;

    if JSON_Data.Has_Field("ixxlupd") then
      Move( Source => JSON_Data.Get("ixxlupd"), Target => Data.Ixxlupd , Drop => Right);
    end if;

    if JSON_Data.Has_Field("ixxluts") then
      declare
        Tmp : String := JSON_Data.Get("ixxluts");
      begin  -- "marketStartTime":"2013-06-22T17:39:00.000Z"
        Data.Ixxluts := Calendar2.To_Time_Type(Tmp(1..10), Tmp(12..23));
      end;
    end if;

    return Data;
  end From_JSON;

  function To_Xml(Data      : in Table_Abets.Data_Type;
                  Ret_Start : in Boolean;
                  Ret_Data  : in Boolean;
                  Ret_End   : in Boolean) return String is
    Ls      : constant String := "";
    S_Start : constant String := "<ABETS_ROW>" & Ls;
    S_End   : constant String := "</ABETS_ROW>" & Ls;
    S1 : constant String :=
          "<BETID>" & Utils.Trim(Data.Betid'Img) & "</BETID>" & Ls;
    S2 : constant String :=
          "<MARKETID>" & Utils.Trim(Data.Marketid) & "</MARKETID>" & Ls;
    S3 : constant String :=
          "<BETMODE>" & Utils.Trim(Data.Betmode'Img) & "</BETMODE>" & Ls;
    S4 : constant String :=
          "<POWERDAYS>" & Utils.Trim(Data.Powerdays'Img) & "</POWERDAYS>" & Ls;
    S5 : constant String :=
          "<SELECTIONID>" & Utils.Trim(Data.Selectionid'Img) & "</SELECTIONID>" & Ls;
    S6 : constant String :=
          "<REFERENCE>" & Utils.Trim(Data.Reference) & "</REFERENCE>" & Ls;
    S7 : constant String :=
          "<SIZE>" & Utils.F8_Image(Data.Size) & "</SIZE>" & Ls;
    S8 : constant String :=
          "<PRICE>" & Utils.F8_Image(Data.Price) & "</PRICE>" & Ls;
    S9 : constant String :=
          "<SIDE>" & Utils.Trim(Data.Side) & "</SIDE>" & Ls;
    S10 : constant String :=
          "<BETNAME>" & Utils.Trim(Data.Betname) & "</BETNAME>" & Ls;
    S11 : constant String :=
          "<BETWON>" & Utils.Trim(Data.Betwon'Img) & "</BETWON>" & Ls;
    S12 : constant String :=
          "<PROFIT>" & Utils.F8_Image(Data.Profit) & "</PROFIT>" & Ls;
    S13 : constant String :=
          "<STATUS>" & Utils.Trim(Data.Status) & "</STATUS>" & Ls;
    S14 : constant String :=
          "<EXESTATUS>" & Utils.Trim(Data.Exestatus) & "</EXESTATUS>" & Ls;
    S15 : constant String :=
          "<EXEERRCODE>" & Utils.Trim(Data.Exeerrcode) & "</EXEERRCODE>" & Ls;
    S16 : constant String :=
          "<INSTSTATUS>" & Utils.Trim(Data.Inststatus) & "</INSTSTATUS>" & Ls;
    S17 : constant String :=
          "<INSTERRCODE>" & Utils.Trim(Data.Insterrcode) & "</INSTERRCODE>" & Ls;
    S18 : constant String :=
          "<STARTTS>" & Calendar2.String_Date_And_Time(Data.Startts, Milliseconds => True) & "</STARTTS>" & Ls;
    S19 : constant String :=
          "<BETPLACED>" & Calendar2.String_Date_And_Time(Data.Betplaced, Milliseconds => True) & "</BETPLACED>" & Ls;
    S20 : constant String :=
          "<PRICEMATCHED>" & Utils.F8_Image(Data.Pricematched) & "</PRICEMATCHED>" & Ls;
    S21 : constant String :=
          "<SIZEMATCHED>" & Utils.F8_Image(Data.Sizematched) & "</SIZEMATCHED>" & Ls;
    S22 : constant String :=
          "<RUNNERNAME>" & Utils.Trim(Data.Runnername) & "</RUNNERNAME>" & Ls;
    S23 : constant String :=
          "<FULLMARKETNAME>" & Utils.Trim(Data.Fullmarketname) & "</FULLMARKETNAME>" & Ls;
    S24 : constant String :=
          "<SVNREVISION>" & Utils.Trim(Data.Svnrevision) & "</SVNREVISION>" & Ls;
    S25 : constant String :=
          "<IXXLUPD>" & Utils.Trim(Data.Ixxlupd) & "</IXXLUPD>" & Ls;
    S26 : constant String :=
          "<IXXLUTS>" & Calendar2.String_Date_And_Time(Data.Ixxluts, Milliseconds => True) & "</IXXLUTS>" & Ls;
    --------------------------------
    function Get_String(S : in String; Ret : in Boolean) return String is
    begin
      if Ret then return S; else return ""; end if;
    end Get_String;
    --------------------------------
  begin
    return Get_String(S_Start, Ret_Start) & 
           Get_String(
                       S1 &  S2 &  S3 &  S4 &  S5 &  S6 &  S7 &  S8 &  S9 &  S10 &  S11 &  S12 &  S13 &  S14 &  S15 &  S16 &  S17 &  S18 &  S19 &  S20 &  S21 &  S22 &  S23 &  S24 &  S25 &  S26 , Ret_Data) &
           Get_String(S_End, Ret_End) & Ascii.LF;
  end To_Xml;
    --------------------------------

  --------------------------------------------
  type Abets_Reader is new Sax.Readers.Reader with record
    Current_Tag    : Unbounded_String := Null_Unbounded_String;
    Accumulated    : Unbounded_String := Null_Unbounded_String;
    OK             : Boolean := True;
    Found_Set      : Boolean := True;
    Abets_List     : Table_Abets.Abets_List_Pack2.List;
    Abets_Data     : Table_Abets.Data_Type := Empty_Data;
  end record;

  overriding procedure Start_Element(Handler       : in out Abets_Reader;
                                     Namespace_URI : Unicode.CES.Byte_Sequence := "";
                                     Local_Name    : Unicode.CES.Byte_Sequence := "";
                                     Qname         : Unicode.CES.Byte_Sequence := "";
                                     Atts          : Sax.Attributes.Attributes'Class);

  overriding procedure End_Element(Handler         : in out Abets_Reader;
                                   Namespace_URI   : Unicode.CES.Byte_Sequence := "";
                                   Local_Name      : Unicode.CES.Byte_Sequence := "";
                                   Qname           : Unicode.CES.Byte_Sequence := "");

  overriding procedure Characters(Handler          : in out Abets_Reader;
                                  Ch               : Unicode.CES.Byte_Sequence := "");

  --------------------------------------------
  overriding procedure Start_Element(Handler       : in out Abets_Reader;
                          Namespace_URI : Unicode.CES.Byte_Sequence := "";
                          Local_Name    : Unicode.CES.Byte_Sequence := "";
                          Qname         : Unicode.CES.Byte_Sequence := "";
                          Atts          : Sax.Attributes.Attributes'Class) is
    pragma Warnings(Off,Namespace_URI);
    pragma Warnings(Off,Qname);
    pragma Warnings(Off,Atts);
    The_Tag : constant String := Local_Name;
  begin
    Handler.Current_Tag := To_Unbounded_String(The_Tag);
    Handler.Accumulated := Null_Unbounded_String;
    if The_Tag = Table_Abets_Set_Name then
      Handler.Found_Set := True;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
    when Constraint_Error         => Handler.OK := False;
  end Start_Element;
  --------------------------------------------

  --------------------------------------------
  overriding procedure End_Element(Handler       : in out Abets_Reader;
                        Namespace_URI : Unicode.CES.Byte_Sequence := "";
                        Local_Name    : Unicode.CES.Byte_Sequence := "";
                        Qname         : Unicode.CES.Byte_Sequence := "") is
    pragma Warnings(Off,Namespace_URI);
    pragma Warnings(Off,Qname);
    The_Tag : constant String := Local_Name;
  begin
    if The_Tag = Table_Abets_Set_Name then
      Handler.Found_Set := False;
    elsif The_Tag = Table_Abets_Row_Name then
      if Handler.Found_Set then
        Handler.Abets_List.Append(Handler.Abets_Data);
        Handler.Abets_Data := Empty_Data;
      end if;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
  end End_Element;
  --------------------------------------------

  --------------------------------------------
  overriding procedure Characters(Handler          : in out Abets_Reader;
                       Ch               : Unicode.CES.Byte_Sequence := "") is
    function To_Iso_Latin_15(Str : Unicode.CES.Byte_Sequence) return String is
      use Unicode.Encodings;
    begin
      return  Convert(Str, Get_By_Name("utf-8"), Get_By_Name("iso-8859-15"));
    end To_Iso_Latin_15;
    The_Tag   : constant String := To_String(Handler.Current_Tag);
    The_Value : constant String := To_Iso_Latin_15(Ch);
    procedure Fix_String (Value    : String;
                          Variable : in out String) is
    begin
      Append(Handler.Accumulated, Value);
      Ada.Strings.Fixed.Move(To_String(Handler.Accumulated), Variable);
    end Fix_String;
  begin
    if Handler.Found_Set then
      if The_Tag = Betid_Name then
       Handler.Abets_Data.Betid := Integer_8'value(The_Value);
      elsif The_Tag = Marketid_Name then
       Fix_String(The_Value, Handler.Abets_Data.Marketid);
      elsif The_Tag = Betmode_Name then
       Handler.Abets_Data.Betmode := Integer_4'value(The_Value);
      elsif The_Tag = Powerdays_Name then
       Handler.Abets_Data.Powerdays := Integer_4'value(The_Value);
      elsif The_Tag = Selectionid_Name then
       Handler.Abets_Data.Selectionid := Integer_4'value(The_Value);
      elsif The_Tag = Reference_Name then
       Fix_String(The_Value, Handler.Abets_Data.Reference);
      elsif The_Tag = Size_Name then
       Handler.Abets_Data.Size := Fixed_Type'value(The_Value);
      elsif The_Tag = Price_Name then
       Handler.Abets_Data.Price := Fixed_Type'value(The_Value);
      elsif The_Tag = Side_Name then
       Fix_String(The_Value, Handler.Abets_Data.Side);
      elsif The_Tag = Betname_Name then
       Fix_String(The_Value, Handler.Abets_Data.Betname);
      elsif The_Tag = Betwon_Name then
       Handler.Abets_Data.Betwon := Boolean'value(The_Value);
      elsif The_Tag = Profit_Name then
       Handler.Abets_Data.Profit := Fixed_Type'value(The_Value);
      elsif The_Tag = Status_Name then
       Fix_String(The_Value, Handler.Abets_Data.Status);
      elsif The_Tag = Exestatus_Name then
       Fix_String(The_Value, Handler.Abets_Data.Exestatus);
      elsif The_Tag = Exeerrcode_Name then
       Fix_String(The_Value, Handler.Abets_Data.Exeerrcode);
      elsif The_Tag = Inststatus_Name then
       Fix_String(The_Value, Handler.Abets_Data.Inststatus);
      elsif The_Tag = Insterrcode_Name then
       Fix_String(The_Value, Handler.Abets_Data.Insterrcode);
      elsif The_Tag = Startts_Name then
       Handler.Abets_Data.Startts := Calendar2.To_Time_Type(The_Value(1..11), The_Value(13..24));
      elsif The_Tag = Betplaced_Name then
       Handler.Abets_Data.Betplaced := Calendar2.To_Time_Type(The_Value(1..11), The_Value(13..24));
      elsif The_Tag = Pricematched_Name then
       Handler.Abets_Data.Pricematched := Fixed_Type'value(The_Value);
      elsif The_Tag = Sizematched_Name then
       Handler.Abets_Data.Sizematched := Fixed_Type'value(The_Value);
      elsif The_Tag = Runnername_Name then
       Fix_String(The_Value, Handler.Abets_Data.Runnername);
      elsif The_Tag = Fullmarketname_Name then
       Fix_String(The_Value, Handler.Abets_Data.Fullmarketname);
      elsif The_Tag = Svnrevision_Name then
       Fix_String(The_Value, Handler.Abets_Data.Svnrevision);
      elsif The_Tag = Ixxlupd_Name then
       Fix_String(The_Value, Handler.Abets_Data.Ixxlupd);
      elsif The_Tag = Ixxluts_Name then
       Handler.Abets_Data.Ixxluts := Calendar2.To_Time_Type(The_Value(1..11), The_Value(13..24));
      end if;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
  end Characters;

  --------------------------------------------


  function To_Map (Data : Table_Abets.Data_Type'class) return Table_Abets.Abets_Map_Pack_String.Map is
    Tmp_Map :  Table_Abets.Abets_Map_Pack_String.Map;
    Key : Key_Type := (others => ' ');
    Tmp_U_B_String : Unbounded_String := Null_Unbounded_String;
    Tmp_String     : String(1..1);
    pragma Warnings(Off, Tmp_String); -- used only if we have Character fields (ie String(1..1)
  begin
    Move("BETID", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Betid'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("MARKETID", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Marketid);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("BETMODE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Betmode'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("POWERDAYS", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Powerdays'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("SELECTIONID", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Selectionid'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("REFERENCE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Reference);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("SIZE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Size'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("PRICE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Price'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("SIDE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Side);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("BETNAME", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Betname);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("BETWON", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Betwon'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("PROFIT", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Profit'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("STATUS", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Status);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("EXESTATUS", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Exestatus);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("EXEERRCODE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Exeerrcode);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("INSTSTATUS", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Inststatus);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("INSTERRCODE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Insterrcode);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("STARTTS", Key);
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Startts));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("BETPLACED", Key);
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Betplaced));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("PRICEMATCHED", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Pricematched'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("SIZEMATCHED", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Sizematched'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("RUNNERNAME", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Runnername);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("FULLMARKETNAME", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Fullmarketname);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("SVNREVISION", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Svnrevision);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("IXXLUPD", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Ixxlupd);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("IXXLUTS", Key);
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Ixxluts));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    return Tmp_Map;
  end To_Map;
 ---------------------------


  function To_Map (Data : Table_Abets.Data_Type'class) return Table_Abets.Abets_Map_Pack_Column_Type.Map is
    Tmp_Map :  Table_Abets.Abets_Map_Pack_Column_Type.Map;
    Key : Column_Type;
    Tmp_U_B_String : Unbounded_String := Null_Unbounded_String;
    Tmp_String     : String(1..1);
    pragma Warnings(Off, Tmp_String); -- used only if we have Character fields (ie String(1..1)
  begin
    Key := Betid;
    Tmp_U_B_String := To_Unbounded_String(Data.Betid'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Marketid;
    Tmp_U_B_String := To_Unbounded_String(Data.Marketid);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Betmode;
    Tmp_U_B_String := To_Unbounded_String(Data.Betmode'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Powerdays;
    Tmp_U_B_String := To_Unbounded_String(Data.Powerdays'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Selectionid;
    Tmp_U_B_String := To_Unbounded_String(Data.Selectionid'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Reference;
    Tmp_U_B_String := To_Unbounded_String(Data.Reference);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Size;
    Tmp_U_B_String := To_Unbounded_String(Data.Size'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Price;
    Tmp_U_B_String := To_Unbounded_String(Data.Price'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Side;
    Tmp_U_B_String := To_Unbounded_String(Data.Side);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Betname;
    Tmp_U_B_String := To_Unbounded_String(Data.Betname);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Betwon;
    Tmp_U_B_String := To_Unbounded_String(Data.Betwon'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Profit;
    Tmp_U_B_String := To_Unbounded_String(Data.Profit'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Status;
    Tmp_U_B_String := To_Unbounded_String(Data.Status);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Exestatus;
    Tmp_U_B_String := To_Unbounded_String(Data.Exestatus);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Exeerrcode;
    Tmp_U_B_String := To_Unbounded_String(Data.Exeerrcode);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Inststatus;
    Tmp_U_B_String := To_Unbounded_String(Data.Inststatus);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Insterrcode;
    Tmp_U_B_String := To_Unbounded_String(Data.Insterrcode);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Startts;
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Startts));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Betplaced;
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Betplaced));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Pricematched;
    Tmp_U_B_String := To_Unbounded_String(Data.Pricematched'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Sizematched;
    Tmp_U_B_String := To_Unbounded_String(Data.Sizematched'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Runnername;
    Tmp_U_B_String := To_Unbounded_String(Data.Runnername);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Fullmarketname;
    Tmp_U_B_String := To_Unbounded_String(Data.Fullmarketname);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Svnrevision;
    Tmp_U_B_String := To_Unbounded_String(Data.Svnrevision);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Ixxlupd;
    Tmp_U_B_String := To_Unbounded_String(Data.Ixxlupd);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Ixxluts;
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Ixxluts));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    return Tmp_Map;
  end To_Map;
 ---------------------------


  procedure Read_Marketid(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I2_Marketid_O.Prepare("select * from ABETS " &
                "where MARKETID =:MARKETID " &
            "order by " & 
            "BETID");
    Stm_Select_I2_Marketid_O.Set("MARKETID", Data.Marketid);
      Read_List(Stm_Select_I2_Marketid_O, List, Max);
    else
    Stm_Select_I2_Marketid.Prepare("select * from ABETS " &
                "where MARKETID =:MARKETID " &
            "");
    Stm_Select_I2_Marketid.Set("MARKETID", Data.Marketid);
      Read_List(Stm_Select_I2_Marketid, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Marketid;
-----------------------------------------------



  procedure Read_Betwon(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I3_Betwon_O.Prepare("select * from ABETS " &
                "where BETWON =:BETWON " &
            "order by " & 
            "BETID");
    Stm_Select_I3_Betwon_O.Set("BETWON", Data.Betwon);
      Read_List(Stm_Select_I3_Betwon_O, List, Max);
    else
    Stm_Select_I3_Betwon.Prepare("select * from ABETS " &
                "where BETWON =:BETWON " &
            "");
    Stm_Select_I3_Betwon.Set("BETWON", Data.Betwon);
      Read_List(Stm_Select_I3_Betwon, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Betwon;
-----------------------------------------------



  procedure Read_Powerdays(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I4_Powerdays_O.Prepare("select * from ABETS " &
                "where POWERDAYS =:POWERDAYS " &
            "order by " & 
            "BETID");
    Stm_Select_I4_Powerdays_O.Set("POWERDAYS", Data.Powerdays);
      Read_List(Stm_Select_I4_Powerdays_O, List, Max);
    else
    Stm_Select_I4_Powerdays.Prepare("select * from ABETS " &
                "where POWERDAYS =:POWERDAYS " &
            "");
    Stm_Select_I4_Powerdays.Set("POWERDAYS", Data.Powerdays);
      Read_List(Stm_Select_I4_Powerdays, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Powerdays;
-----------------------------------------------



  procedure Read_Betplaced(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I5_Betplaced_O.Prepare("select * from ABETS " &
                "where BETPLACED =:BETPLACED " &
            "order by " & 
            "BETID");
    Stm_Select_I5_Betplaced_O.Set_Timestamp("BETPLACED", Data.Betplaced);
      Read_List(Stm_Select_I5_Betplaced_O, List, Max);
    else
    Stm_Select_I5_Betplaced.Prepare("select * from ABETS " &
                "where BETPLACED =:BETPLACED " &
            "");
    Stm_Select_I5_Betplaced.Set_Timestamp("BETPLACED", Data.Betplaced);
      Read_List(Stm_Select_I5_Betplaced, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Betplaced;
-----------------------------------------------



  procedure Read_Startts(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I6_Startts_O.Prepare("select * from ABETS " &
                "where STARTTS =:STARTTS " &
            "order by " & 
            "BETID");
    Stm_Select_I6_Startts_O.Set_Timestamp("STARTTS", Data.Startts);
      Read_List(Stm_Select_I6_Startts_O, List, Max);
    else
    Stm_Select_I6_Startts.Prepare("select * from ABETS " &
                "where STARTTS =:STARTTS " &
            "");
    Stm_Select_I6_Startts.Set_Timestamp("STARTTS", Data.Startts);
      Read_List(Stm_Select_I6_Startts, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Startts;
-----------------------------------------------



  procedure Read_Betname(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I7_Betname_O.Prepare("select * from ABETS " &
                "where BETNAME =:BETNAME " &
            "order by " & 
            "BETID");
    Stm_Select_I7_Betname_O.Set("BETNAME", Data.Betname);
      Read_List(Stm_Select_I7_Betname_O, List, Max);
    else
    Stm_Select_I7_Betname.Prepare("select * from ABETS " &
                "where BETNAME =:BETNAME " &
            "");
    Stm_Select_I7_Betname.Set("BETNAME", Data.Betname);
      Read_List(Stm_Select_I7_Betname, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Betname;
-----------------------------------------------



  procedure Read_Status(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I8_Status_O.Prepare("select * from ABETS " &
                "where STATUS =:STATUS " &
            "order by " & 
            "BETID");
    Stm_Select_I8_Status_O.Set("STATUS", Data.Status);
      Read_List(Stm_Select_I8_Status_O, List, Max);
    else
    Stm_Select_I8_Status.Prepare("select * from ABETS " &
                "where STATUS =:STATUS " &
            "");
    Stm_Select_I8_Status.Set("STATUS", Data.Status);
      Read_List(Stm_Select_I8_Status, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Status;
-----------------------------------------------



  procedure Read_Reference(
                           Data  : in out Table_Abets.Data_Type'class;
                           List  : in out Abets_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I9_Reference_O.Prepare("select * from ABETS " &
                "where REFERENCE =:REFERENCE " &
            "order by " & 
            "BETID");
    Stm_Select_I9_Reference_O.Set("REFERENCE", Data.Reference);
      Read_List(Stm_Select_I9_Reference_O, List, Max);
    else
    Stm_Select_I9_Reference.Prepare("select * from ABETS " &
                "where REFERENCE =:REFERENCE " &
            "");
    Stm_Select_I9_Reference.Set("REFERENCE", Data.Reference);
      Read_List(Stm_Select_I9_Reference, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Reference;
-----------------------------------------------






  procedure From_Xml(Xml_Filename : in Unbounded_String;
                     A_List       : in out Abets_List_Pack2.List) is
    My_Reader   : Abets_Reader;
    Input       : File_Input;
  begin
    My_Reader.Abets_List := A_List;
    My_Reader.Current_Tag := Null_Unbounded_String;
    Open(To_String(Xml_Filename), Input);
    My_Reader.Set_Feature(Validation_Feature,False);
    My_Reader.Parse(Input);
    Input.Close;
    if not My_Reader.OK then
       My_Reader.Abets_List.Clear;
    end if;
    A_List := My_Reader.Abets_List;
  end From_Xml;

end Table_Abets;
