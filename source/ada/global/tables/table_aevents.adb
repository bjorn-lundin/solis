
-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- repo                                              
--                                                   
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with Process_Io, Utils;
with Ada.Strings.Fixed; use Ada.Strings.Fixed;
with Sax.Readers;              use Sax.Readers;
with Input_Sources.File;       use Input_Sources.File;
with Unicode.CES;
with Unicode.Encodings;
with Sax.Attributes;



package body Table_Aevents is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  Stm_Delete_With_Check,
  Stm_Update_With_Check  : Sql.Statement_Type;


  -- Primary keys, when several fields
  Stm_Select_I1_Eventid,
  Stm_Select_I1_Eventid_O,
  Stm_Delete_I1_Eventid : Sql.Statement_Type; 

  -- non unique index 
  Stm_Select_Count_I2_Countrycode,
  Stm_Select_I2_Countrycode,
  Stm_Delete_I2_Countrycode,
  Stm_Select_I2_Countrycode_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I3_Opents,
  Stm_Select_I3_Opents,
  Stm_Delete_I3_Opents,
  Stm_Select_I3_Opents_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I4_Eventtypeid,
  Stm_Select_I4_Eventtypeid,
  Stm_Delete_I4_Eventtypeid,
  Stm_Select_I4_Eventtypeid_O : Sql.Statement_Type;

  -- non unique index 
  Stm_Select_Count_I5_Ixxluts,
  Stm_Select_I5_Ixxluts,
  Stm_Delete_I5_Ixxluts,
  Stm_Select_I5_Ixxluts_O : Sql.Statement_Type;



  -- Procedures for all DBMS

  -- Procedures for DBMS SQL
  -- Primary key

  function Get(Stm : in Sql.Statement_Type) return Table_Aevents.Data_Type is
    Data : Table_Aevents.Data_Type;
  begin
    Stm.Get("EVENTID", Data.Eventid);
    Stm.Get("EVENTNAME", Data.Eventname);
    Stm.Get("COUNTRYCODE", Data.Countrycode);
    Stm.Get("TIMEZONE", Data.Timezone);
    Stm.Get_Timestamp("OPENTS", Data.Opents);
    Stm.Get("EVENTTYPEID", Data.Eventtypeid);
    Stm.Get("IXXLUPD", Data.Ixxlupd);
    Stm.Get_Timestamp("IXXLUTS", Data.Ixxluts);

    return Data;
  end Get;
---------------------------------------------


  function Get(
                  Eventid : String) return Table_Aevents.Data_Type is
    Data       : Table_Aevents.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Eventid := Eventid;
    Data.Read(End_Of_Set);
    return Data;
  end Get;



  procedure Read_All(List  : in out Aevents_List_Pack2.List;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans   : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
      Stm_Select_All_O.Prepare("select * from AEVENTS order by " &
                  "EVENTID");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Stm_Select_All.Prepare("select * from AEVENTS");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;
  end Read_All;


  procedure Read_List(Stm   : in     Sql.Statement_Type;
                      List  : in out Aevents_List_Pack2.List;
                      Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans  : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction  : Sql.Transaction_Type;
    Count        : Integer_4 := 0;
    Data         : Table_Aevents.Data_Type;
    Eos          : Boolean := False;
  begin
    if Start_Trans then Transaction.Start; end if;
    Stm.Open_Cursor;
    loop
      Stm.Fetch(Eos);
      exit when Eos or Count > Max;
      Data := Get(Stm);
      List.Append(Data);
      Count := Count +1;
    end loop;
    Stm.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
  end Read_List;


  function Is_Existing(
                  Eventid : String) return Boolean is
    Data       : Table_Aevents.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Eventid := Eventid;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;


  procedure Read(Data       : in out Table_Aevents.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    Stm_Select.Prepare("select * from AEVENTS " &
                "where EVENTID =:EVENTID " &
            "");
    Stm_Select.Set("EVENTID", Data.Eventid);
    Stm_Select.Open_Cursor;
    Stm_Select.Fetch(End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Stm_Select.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
  end Read;

  procedure Delete(Data : in Table_Aevents.Data_Type) is
  begin
    Stm_Delete.Prepare("delete from AEVENTS " &
                "where EVENTID =:EVENTID " &
            "");
    Stm_Delete.Set("EVENTID", Data.Eventid);
    Stm_Delete.Execute;
  end Delete;

  procedure Update(Data : in out Table_Aevents.Data_Type ; Keep_Timestamp : in Boolean := False) is
    Now     : Calendar2.Time_Type := Calendar2.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Stm_Update.Prepare("update AEVENTS set  " &
            "EVENTNAME=:EVENTNAME, " &
            "COUNTRYCODE=:COUNTRYCODE, " &
            "TIMEZONE=:TIMEZONE, " &
            "OPENTS=:OPENTS, " &
            "EVENTTYPEID=:EVENTTYPEID, " &
            "IXXLUPD=:IXXLUPD, " &
            "IXXLUTS=:IXXLUTS " &
            "where EVENTID=:EVENTID " &
            "");

    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
      Stm_Update.Set("EVENTNAME", Data.Eventname);
      Stm_Update.Set("COUNTRYCODE", Data.Countrycode);
      Stm_Update.Set("TIMEZONE", Data.Timezone);
      Stm_Update.Set_Timestamp("OPENTS", Data.Opents);
      Stm_Update.Set("EVENTTYPEID", Data.Eventtypeid);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name(1..15);
    end if;
      Stm_Update.Set("IXXLUPD", Data.Ixxlupd);
      Stm_Update.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Update.Set("EVENTID", Data.Eventid);
    Stm_Update.Execute;
  end Update;

  procedure Insert(Data : in out Table_Aevents.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Calendar2.Time_Type := Calendar2.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
    Stm_Insert.Prepare("insert into AEVENTS values (" &
         ":EVENTID," &
         ":EVENTNAME," &
         ":COUNTRYCODE," &
         ":TIMEZONE," &
         ":OPENTS," &
         ":EVENTTYPEID," &
         ":IXXLUPD," &
         ":IXXLUTS)");

    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
      Stm_Insert.Set("EVENTID", Data.Eventid);
      Stm_Insert.Set("EVENTNAME", Data.Eventname);
      Stm_Insert.Set("COUNTRYCODE", Data.Countrycode);
      Stm_Insert.Set("TIMEZONE", Data.Timezone);
      Stm_Insert.Set_Timestamp("OPENTS", Data.Opents);
      Stm_Insert.Set("EVENTTYPEID", Data.Eventtypeid);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name(1..15);
    end if;
      Stm_Insert.Set("IXXLUPD", Data.Ixxlupd);
      Stm_Insert.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Insert.Execute;
  end Insert;
--------------------------------------------
  procedure Delete_Withcheck(Data : in Table_Aevents.Data_Type) is
  begin
    Stm_Delete_With_Check.Prepare("delete from AEVENTS " &
                "where EVENTID =:EVENTID " &
            "and IXXLUPD = :IXXLUPD " &
            "and IXXLUTS = :IXXLUTS " &
            "");
    Stm_Delete_With_Check.Set("EVENTID", Data.Eventid);
    Stm_Delete_With_Check.Set("IXXLUPD", Data.Ixxlupd);
    Stm_Delete_With_Check.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Delete_With_Check.Execute;
  end Delete_Withcheck;
--------------------------------------------
  procedure Update_Withcheck(Data : in out Table_Aevents.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Calendar2.Time_Type := Calendar2.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Stm_Update_With_Check.Prepare("update AEVENTS set  " &
            "EVENTNAME=:EVENTNAME, " &
            "COUNTRYCODE=:COUNTRYCODE, " &
            "TIMEZONE=:TIMEZONE, " &
            "OPENTS=:OPENTS, " &
            "EVENTTYPEID=:EVENTTYPEID, " &
            "IXXLUPD=:IXXLUPD, " &
            "IXXLUTS=:IXXLUTS " &
            "where EVENTID=:EVENTID " &
    "and IXXLUPD = :OLD_IXXLUPD " &
    "and IXXLUTS = :OLD_IXXLUTS " &
            "");
    Stm_Update_With_Check.Set("EVENTID", Data.Eventid);
    Stm_Update_With_Check.Set("OLD_IXXLUPD", Data.Ixxlupd );
    Stm_Update_With_Check.Set_Timestamp("OLD_IXXLUTS", Data.Ixxluts );

    if not Keep_Timestamp then
      Data.Ixxluts := Now;
    end if;
      Stm_Update_With_Check.Set("EVENTNAME", Data.Eventname);
      Stm_Update_With_Check.Set("COUNTRYCODE", Data.Countrycode);
      Stm_Update_With_Check.Set("TIMEZONE", Data.Timezone);
      Stm_Update_With_Check.Set_Timestamp("OPENTS", Data.Opents);
      Stm_Update_With_Check.Set("EVENTTYPEID", Data.Eventtypeid);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name(1..15);
    end if;
      Stm_Update_With_Check.Set("IXXLUPD", Data.Ixxlupd);
      Stm_Update_With_Check.Set_Timestamp("IXXLUTS", Data.Ixxluts);
    Stm_Update_With_Check.Execute;
  end Update_Withcheck;
--------------------------------------------
   -- stop Print_Def_Functions_Body.Primary_Procs_Body


  -- non unique index
  procedure Read_One_Countrycode(
                           Data       : in out Table_Aevents.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Aevents_List_Pack2.List;
  begin
    Data.Read_Countrycode(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Countrycode;
  --------------------------------------------

  -- non unique index
  function Count_Countrycode(Data : Table_Aevents.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I2_Countrycode.Prepare("select count('a') from AEVENTS " &
                "where COUNTRYCODE =:COUNTRYCODE " &
            "");
    Stm_Select_Count_I2_Countrycode.Set("COUNTRYCODE", Data.Countrycode);

    Stm_Select_Count_I2_Countrycode.Open_Cursor;
    Stm_Select_Count_I2_Countrycode.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I2_Countrycode.Get(1, Count);
    end if;
    Stm_Select_Count_I2_Countrycode.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Countrycode;
  --------------------------------------------

  -- non unique index
  procedure Delete_Countrycode(Data  : in     Table_Aevents.Data_Type) is
  begin

    Stm_Delete_I2_Countrycode.Prepare("delete from AEVENTS " &
                "where COUNTRYCODE =:COUNTRYCODE " &
            "");
    Stm_Delete_I2_Countrycode.Set("COUNTRYCODE", Data.Countrycode);

    Stm_Delete_I2_Countrycode.Execute;
  end Delete_Countrycode;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I2(Countrycode : in String) return Boolean is
    Data       : Table_Aevents.Data_Type;
    Exists     : Boolean := False;
    List       : Aevents_List_Pack2.List;
  begin
    Data.Countrycode := Countrycode;
    Read_Countrycode(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I2;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Opents(
                           Data       : in out Table_Aevents.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Aevents_List_Pack2.List;
  begin
    Data.Read_Opents(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Opents;
  --------------------------------------------

  -- non unique index
  function Count_Opents(Data : Table_Aevents.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I3_Opents.Prepare("select count('a') from AEVENTS " &
                "where OPENTS =:OPENTS " &
            "");
    Stm_Select_Count_I3_Opents.Set_Timestamp("OPENTS", Data.Opents);

    Stm_Select_Count_I3_Opents.Open_Cursor;
    Stm_Select_Count_I3_Opents.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I3_Opents.Get(1, Count);
    end if;
    Stm_Select_Count_I3_Opents.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Opents;
  --------------------------------------------

  -- non unique index
  procedure Delete_Opents(Data  : in     Table_Aevents.Data_Type) is
  begin

    Stm_Delete_I3_Opents.Prepare("delete from AEVENTS " &
                "where OPENTS =:OPENTS " &
            "");
    Stm_Delete_I3_Opents.Set_Timestamp("OPENTS", Data.Opents);

    Stm_Delete_I3_Opents.Execute;
  end Delete_Opents;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I3(Opents : in Time_Type) return Boolean is
    Data       : Table_Aevents.Data_Type;
    Exists     : Boolean := False;
    List       : Aevents_List_Pack2.List;
  begin
    Data.Opents := Opents;
    Read_Opents(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I3;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Eventtypeid(
                           Data       : in out Table_Aevents.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Aevents_List_Pack2.List;
  begin
    Data.Read_Eventtypeid(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Eventtypeid;
  --------------------------------------------

  -- non unique index
  function Count_Eventtypeid(Data : Table_Aevents.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I4_Eventtypeid.Prepare("select count('a') from AEVENTS " &
                "where EVENTTYPEID =:EVENTTYPEID " &
            "");
    Stm_Select_Count_I4_Eventtypeid.Set("EVENTTYPEID", Data.Eventtypeid);

    Stm_Select_Count_I4_Eventtypeid.Open_Cursor;
    Stm_Select_Count_I4_Eventtypeid.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I4_Eventtypeid.Get(1, Count);
    end if;
    Stm_Select_Count_I4_Eventtypeid.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Eventtypeid;
  --------------------------------------------

  -- non unique index
  procedure Delete_Eventtypeid(Data  : in     Table_Aevents.Data_Type) is
  begin

    Stm_Delete_I4_Eventtypeid.Prepare("delete from AEVENTS " &
                "where EVENTTYPEID =:EVENTTYPEID " &
            "");
    Stm_Delete_I4_Eventtypeid.Set("EVENTTYPEID", Data.Eventtypeid);

    Stm_Delete_I4_Eventtypeid.Execute;
  end Delete_Eventtypeid;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I4(Eventtypeid : in Integer_4) return Boolean is
    Data       : Table_Aevents.Data_Type;
    Exists     : Boolean := False;
    List       : Aevents_List_Pack2.List;
  begin
    Data.Eventtypeid := Eventtypeid;
    Read_Eventtypeid(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I4;
  --------------------------------------------




  -- non unique index
  procedure Read_One_Ixxluts(
                           Data       : in out Table_Aevents.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Aevents_List_Pack2.List;
  begin
    Data.Read_Ixxluts(List, Order, 1);
    if List.Is_Empty then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Data := List.First_Element;
    end if;
    List.Clear;
  end Read_One_Ixxluts;
  --------------------------------------------

  -- non unique index
  function Count_Ixxluts(Data : Table_Aevents.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;

    Stm_Select_Count_I5_Ixxluts.Prepare("select count('a') from AEVENTS " &
                "where IXXLUTS =:IXXLUTS " &
            "");
    Stm_Select_Count_I5_Ixxluts.Set_Timestamp("IXXLUTS", Data.Ixxluts);

    Stm_Select_Count_I5_Ixxluts.Open_Cursor;
    Stm_Select_Count_I5_Ixxluts.Fetch(End_Of_Set);
    if not End_Of_Set then
      Stm_Select_Count_I5_Ixxluts.Get(1, Count);
    end if;
    Stm_Select_Count_I5_Ixxluts.Close_Cursor;
    if Start_Trans then Transaction.Commit; end if;
    return Count;
  end Count_Ixxluts;
  --------------------------------------------

  -- non unique index
  procedure Delete_Ixxluts(Data  : in     Table_Aevents.Data_Type) is
  begin

    Stm_Delete_I5_Ixxluts.Prepare("delete from AEVENTS " &
                "where IXXLUTS =:IXXLUTS " &
            "");
    Stm_Delete_I5_Ixxluts.Set_Timestamp("IXXLUTS", Data.Ixxluts);

    Stm_Delete_I5_Ixxluts.Execute;
  end Delete_Ixxluts;

  --------------------------------------------

  -- non unique index
  function Is_Existing_I5(Ixxluts : in Time_Type) return Boolean is
    Data       : Table_Aevents.Data_Type;
    Exists     : Boolean := False;
    List       : Aevents_List_Pack2.List;
  begin
    Data.Ixxluts := Ixxluts;
    Read_Ixxluts(Data, List, False, 1);
    Exists := not List.Is_Empty;
    List.Clear;
    return Exists;
  end Is_Existing_I5;
  --------------------------------------------





  -- Procedures for all DBMS


  function To_String(Data : in Table_Aevents.Data_Type) return String is
  begin
    return
          "Eventid = " & Utils.Trim(Data.Eventid) & " " &
          "Eventname = " & Utils.Trim(Data.Eventname) & " " &
          "Countrycode = " & Utils.Trim(Data.Countrycode) & " " &
          "Timezone = " & Utils.Trim(Data.Timezone) & " " &
          "Opents = " & Calendar2.String_Date_And_Time(Data.Opents, Milliseconds => True ) & " " &
          "Eventtypeid = " & Utils.Trim(Data.Eventtypeid'Img) & " " &
          "Ixxlupd = " & Utils.Trim(Data.Ixxlupd) & " " &
          "Ixxluts = " & Calendar2.String_Date_And_Time(Data.Ixxluts, Milliseconds => True ) & " " &
          "";
  end To_String;

  function To_JSON(Data : in Table_Aevents.Data_Type) return JSON_Value is
    Json_Data : JSON_Value := Create_Object;
  begin
    Json_Data.Set_Field(Field_Name => "eventid", Field => Utils.Trim(Data.Eventid));
    Json_Data.Set_Field(Field_Name => "eventname", Field => Utils.Trim(Data.Eventname));
    Json_Data.Set_Field(Field_Name => "countrycode", Field => Utils.Trim(Data.Countrycode));
    Json_Data.Set_Field(Field_Name => "timezone", Field => Utils.Trim(Data.Timezone));
    Json_Data.Set_Field(Field_Name => "opents", Field => Data.Opents.To_String);
    Json_Data.Set_Field(Field_Name => "eventtypeid", Field => Long_Integer(Data.Eventtypeid));
    Json_Data.Set_Field(Field_Name => "ixxlupd", Field => Utils.Trim(Data.Ixxlupd));
    Json_Data.Set_Field(Field_Name => "ixxluts", Field => Data.Ixxluts.To_String);
    return Json_Data;
  end To_JSON;

  function From_JSON(JSON_Data : in JSON_Value) return Table_Aevents.Data_Type is
    use Ada.Strings;
    Data : Table_Aevents.Data_Type;
  begin
    if JSON_Data.Has_Field("eventid") then
      Move( Source => JSON_Data.Get("eventid"), Target => Data.Eventid , Drop => Right);
    end if;

    if JSON_Data.Has_Field("eventname") then
      Move( Source => JSON_Data.Get("eventname"), Target => Data.Eventname , Drop => Right);
    end if;

    if JSON_Data.Has_Field("countrycode") then
      Move( Source => JSON_Data.Get("countrycode"), Target => Data.Countrycode , Drop => Right);
    end if;

    if JSON_Data.Has_Field("timezone") then
      Move( Source => JSON_Data.Get("timezone"), Target => Data.Timezone , Drop => Right);
    end if;

    if JSON_Data.Has_Field("opents") then
      declare
        Tmp : String := JSON_Data.Get("opents");
      begin  -- "marketStartTime":"2013-06-22T17:39:00.000Z"
        Data.Opents := Calendar2.To_Time_Type(Tmp(1..10), Tmp(12..23));
      end;
    end if;

    if JSON_Data.Has_Field("eventtypeid") then
      declare
        Tmp : Long_Integer := 0;
      begin
        Tmp := JSON_Data.Get("eventtypeid");
        Data.Eventtypeid := Integer_4(Tmp);
      end;
    end if;

    if JSON_Data.Has_Field("ixxlupd") then
      Move( Source => JSON_Data.Get("ixxlupd"), Target => Data.Ixxlupd , Drop => Right);
    end if;

    if JSON_Data.Has_Field("ixxluts") then
      declare
        Tmp : String := JSON_Data.Get("ixxluts");
      begin  -- "marketStartTime":"2013-06-22T17:39:00.000Z"
        Data.Ixxluts := Calendar2.To_Time_Type(Tmp(1..10), Tmp(12..23));
      end;
    end if;

    return Data;
  end From_JSON;

  function To_Xml(Data      : in Table_Aevents.Data_Type;
                  Ret_Start : in Boolean;
                  Ret_Data  : in Boolean;
                  Ret_End   : in Boolean) return String is
    Ls      : constant String := "";
    S_Start : constant String := "<AEVENTS_ROW>" & Ls;
    S_End   : constant String := "</AEVENTS_ROW>" & Ls;
    S1 : constant String :=
          "<EVENTID>" & Utils.Trim(Data.Eventid) & "</EVENTID>" & Ls;
    S2 : constant String :=
          "<EVENTNAME>" & Utils.Trim(Data.Eventname) & "</EVENTNAME>" & Ls;
    S3 : constant String :=
          "<COUNTRYCODE>" & Utils.Trim(Data.Countrycode) & "</COUNTRYCODE>" & Ls;
    S4 : constant String :=
          "<TIMEZONE>" & Utils.Trim(Data.Timezone) & "</TIMEZONE>" & Ls;
    S5 : constant String :=
          "<OPENTS>" & Calendar2.String_Date_And_Time(Data.Opents, Milliseconds => True) & "</OPENTS>" & Ls;
    S6 : constant String :=
          "<EVENTTYPEID>" & Utils.Trim(Data.Eventtypeid'Img) & "</EVENTTYPEID>" & Ls;
    S7 : constant String :=
          "<IXXLUPD>" & Utils.Trim(Data.Ixxlupd) & "</IXXLUPD>" & Ls;
    S8 : constant String :=
          "<IXXLUTS>" & Calendar2.String_Date_And_Time(Data.Ixxluts, Milliseconds => True) & "</IXXLUTS>" & Ls;
    --------------------------------
    function Get_String(S : in String; Ret : in Boolean) return String is
    begin
      if Ret then return S; else return ""; end if;
    end Get_String;
    --------------------------------
  begin
    return Get_String(S_Start, Ret_Start) & 
           Get_String(
                       S1 &  S2 &  S3 &  S4 &  S5 &  S6 &  S7 &  S8 , Ret_Data) &
           Get_String(S_End, Ret_End) & Ascii.LF;
  end To_Xml;
    --------------------------------

  --------------------------------------------
  type Aevents_Reader is new Sax.Readers.Reader with record
    Current_Tag    : Unbounded_String := Null_Unbounded_String;
    Accumulated    : Unbounded_String := Null_Unbounded_String;
    OK             : Boolean := True;
    Found_Set      : Boolean := True;
    Aevents_List     : Table_Aevents.Aevents_List_Pack2.List;
    Aevents_Data     : Table_Aevents.Data_Type := Empty_Data;
  end record;

  overriding procedure Start_Element(Handler       : in out Aevents_Reader;
                                     Namespace_URI : Unicode.CES.Byte_Sequence := "";
                                     Local_Name    : Unicode.CES.Byte_Sequence := "";
                                     Qname         : Unicode.CES.Byte_Sequence := "";
                                     Atts          : Sax.Attributes.Attributes'Class);

  overriding procedure End_Element(Handler         : in out Aevents_Reader;
                                   Namespace_URI   : Unicode.CES.Byte_Sequence := "";
                                   Local_Name      : Unicode.CES.Byte_Sequence := "";
                                   Qname           : Unicode.CES.Byte_Sequence := "");

  overriding procedure Characters(Handler          : in out Aevents_Reader;
                                  Ch               : Unicode.CES.Byte_Sequence := "");

  --------------------------------------------
  overriding procedure Start_Element(Handler       : in out Aevents_Reader;
                          Namespace_URI : Unicode.CES.Byte_Sequence := "";
                          Local_Name    : Unicode.CES.Byte_Sequence := "";
                          Qname         : Unicode.CES.Byte_Sequence := "";
                          Atts          : Sax.Attributes.Attributes'Class) is
    pragma Warnings(Off,Namespace_URI);
    pragma Warnings(Off,Qname);
    pragma Warnings(Off,Atts);
    The_Tag : constant String := Local_Name;
  begin
    Handler.Current_Tag := To_Unbounded_String(The_Tag);
    Handler.Accumulated := Null_Unbounded_String;
    if The_Tag = Table_Aevents_Set_Name then
      Handler.Found_Set := True;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
    when Constraint_Error         => Handler.OK := False;
  end Start_Element;
  --------------------------------------------

  --------------------------------------------
  overriding procedure End_Element(Handler       : in out Aevents_Reader;
                        Namespace_URI : Unicode.CES.Byte_Sequence := "";
                        Local_Name    : Unicode.CES.Byte_Sequence := "";
                        Qname         : Unicode.CES.Byte_Sequence := "") is
    pragma Warnings(Off,Namespace_URI);
    pragma Warnings(Off,Qname);
    The_Tag : constant String := Local_Name;
  begin
    if The_Tag = Table_Aevents_Set_Name then
      Handler.Found_Set := False;
    elsif The_Tag = Table_Aevents_Row_Name then
      if Handler.Found_Set then
        Handler.Aevents_List.Append(Handler.Aevents_Data);
        Handler.Aevents_Data := Empty_Data;
      end if;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
  end End_Element;
  --------------------------------------------

  --------------------------------------------
  overriding procedure Characters(Handler          : in out Aevents_Reader;
                       Ch               : Unicode.CES.Byte_Sequence := "") is
    function To_Iso_Latin_15(Str : Unicode.CES.Byte_Sequence) return String is
      use Unicode.Encodings;
    begin
      return  Convert(Str, Get_By_Name("utf-8"), Get_By_Name("iso-8859-15"));
    end To_Iso_Latin_15;
    The_Tag   : constant String := To_String(Handler.Current_Tag);
    The_Value : constant String := To_Iso_Latin_15(Ch);
    procedure Fix_String (Value    : String;
                          Variable : in out String) is
    begin
      Append(Handler.Accumulated, Value);
      Ada.Strings.Fixed.Move(To_String(Handler.Accumulated), Variable);
    end Fix_String;
  begin
    if Handler.Found_Set then
      if The_Tag = Eventid_Name then
       Fix_String(The_Value, Handler.Aevents_Data.Eventid);
      elsif The_Tag = Eventname_Name then
       Fix_String(The_Value, Handler.Aevents_Data.Eventname);
      elsif The_Tag = Countrycode_Name then
       Fix_String(The_Value, Handler.Aevents_Data.Countrycode);
      elsif The_Tag = Timezone_Name then
       Fix_String(The_Value, Handler.Aevents_Data.Timezone);
      elsif The_Tag = Opents_Name then
       Handler.Aevents_Data.Opents := Calendar2.To_Time_Type(The_Value(1..11), The_Value(13..24));
      elsif The_Tag = Eventtypeid_Name then
       Handler.Aevents_Data.Eventtypeid := Integer_4'value(The_Value);
      elsif The_Tag = Ixxlupd_Name then
       Fix_String(The_Value, Handler.Aevents_Data.Ixxlupd);
      elsif The_Tag = Ixxluts_Name then
       Handler.Aevents_Data.Ixxluts := Calendar2.To_Time_Type(The_Value(1..11), The_Value(13..24));
      end if;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
  end Characters;

  --------------------------------------------


  function To_Map (Data : Table_Aevents.Data_Type'class) return Table_Aevents.Aevents_Map_Pack_String.Map is
    Tmp_Map :  Table_Aevents.Aevents_Map_Pack_String.Map;
    Key : Key_Type := (others => ' ');
    Tmp_U_B_String : Unbounded_String := Null_Unbounded_String;
    Tmp_String     : String(1..1);
    pragma Warnings(Off, Tmp_String); -- used only if we have Character fields (ie String(1..1)
  begin
    Move("EVENTID", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Eventid);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("EVENTNAME", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Eventname);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("COUNTRYCODE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Countrycode);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("TIMEZONE", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Timezone);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("OPENTS", Key);
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Opents));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("EVENTTYPEID", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Eventtypeid'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("IXXLUPD", Key);
    Tmp_U_B_String := To_Unbounded_String(Data.Ixxlupd);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Move("IXXLUTS", Key);
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Ixxluts));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    return Tmp_Map;
  end To_Map;
 ---------------------------


  function To_Map (Data : Table_Aevents.Data_Type'class) return Table_Aevents.Aevents_Map_Pack_Column_Type.Map is
    Tmp_Map :  Table_Aevents.Aevents_Map_Pack_Column_Type.Map;
    Key : Column_Type;
    Tmp_U_B_String : Unbounded_String := Null_Unbounded_String;
    Tmp_String     : String(1..1);
    pragma Warnings(Off, Tmp_String); -- used only if we have Character fields (ie String(1..1)
  begin
    Key := Eventid;
    Tmp_U_B_String := To_Unbounded_String(Data.Eventid);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Eventname;
    Tmp_U_B_String := To_Unbounded_String(Data.Eventname);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Countrycode;
    Tmp_U_B_String := To_Unbounded_String(Data.Countrycode);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Timezone;
    Tmp_U_B_String := To_Unbounded_String(Data.Timezone);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Opents;
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Opents));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Eventtypeid;
    Tmp_U_B_String := To_Unbounded_String(Data.Eventtypeid'Img);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Ixxlupd;
    Tmp_U_B_String := To_Unbounded_String(Data.Ixxlupd);
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    Key := Ixxluts;
    Tmp_U_B_String := To_Unbounded_String(String_Date_And_Time(Data.Ixxluts));
    Tmp_Map.Insert(Key, Tmp_U_B_String);

    return Tmp_Map;
  end To_Map;
 ---------------------------


  procedure Read_Countrycode(
                           Data  : in out Table_Aevents.Data_Type'class;
                           List  : in out Aevents_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I2_Countrycode_O.Prepare("select * from AEVENTS " &
                "where COUNTRYCODE =:COUNTRYCODE " &
            "order by " & 
            "EVENTID");
    Stm_Select_I2_Countrycode_O.Set("COUNTRYCODE", Data.Countrycode);
      Read_List(Stm_Select_I2_Countrycode_O, List, Max);
    else
    Stm_Select_I2_Countrycode.Prepare("select * from AEVENTS " &
                "where COUNTRYCODE =:COUNTRYCODE " &
            "");
    Stm_Select_I2_Countrycode.Set("COUNTRYCODE", Data.Countrycode);
      Read_List(Stm_Select_I2_Countrycode, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Countrycode;
-----------------------------------------------



  procedure Read_Opents(
                           Data  : in out Table_Aevents.Data_Type'class;
                           List  : in out Aevents_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I3_Opents_O.Prepare("select * from AEVENTS " &
                "where OPENTS =:OPENTS " &
            "order by " & 
            "EVENTID");
    Stm_Select_I3_Opents_O.Set_Timestamp("OPENTS", Data.Opents);
      Read_List(Stm_Select_I3_Opents_O, List, Max);
    else
    Stm_Select_I3_Opents.Prepare("select * from AEVENTS " &
                "where OPENTS =:OPENTS " &
            "");
    Stm_Select_I3_Opents.Set_Timestamp("OPENTS", Data.Opents);
      Read_List(Stm_Select_I3_Opents, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Opents;
-----------------------------------------------



  procedure Read_Eventtypeid(
                           Data  : in out Table_Aevents.Data_Type'class;
                           List  : in out Aevents_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I4_Eventtypeid_O.Prepare("select * from AEVENTS " &
                "where EVENTTYPEID =:EVENTTYPEID " &
            "order by " & 
            "EVENTID");
    Stm_Select_I4_Eventtypeid_O.Set("EVENTTYPEID", Data.Eventtypeid);
      Read_List(Stm_Select_I4_Eventtypeid_O, List, Max);
    else
    Stm_Select_I4_Eventtypeid.Prepare("select * from AEVENTS " &
                "where EVENTTYPEID =:EVENTTYPEID " &
            "");
    Stm_Select_I4_Eventtypeid.Set("EVENTTYPEID", Data.Eventtypeid);
      Read_List(Stm_Select_I4_Eventtypeid, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Eventtypeid;
-----------------------------------------------



  procedure Read_Ixxluts(
                           Data  : in out Table_Aevents.Data_Type'class;
                           List  : in out Aevents_List_Pack2.List;
                           Order : in     Boolean := False;
                           Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := Sql.Transaction_Status = Sql.None;
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Transaction.Start; end if;
    if Order then
    Stm_Select_I5_Ixxluts_O.Prepare("select * from AEVENTS " &
                "where IXXLUTS =:IXXLUTS " &
            "order by " & 
            "EVENTID");
    Stm_Select_I5_Ixxluts_O.Set_Timestamp("IXXLUTS", Data.Ixxluts);
      Read_List(Stm_Select_I5_Ixxluts_O, List, Max);
    else
    Stm_Select_I5_Ixxluts.Prepare("select * from AEVENTS " &
                "where IXXLUTS =:IXXLUTS " &
            "");
    Stm_Select_I5_Ixxluts.Set_Timestamp("IXXLUTS", Data.Ixxluts);
      Read_List(Stm_Select_I5_Ixxluts, List, Max);
    end if;
    if Start_Trans then Transaction.Commit; end if;      
  end Read_Ixxluts;
-----------------------------------------------



  procedure From_Xml(Xml_Filename : in Unbounded_String;
                     A_List       : in out Aevents_List_Pack2.List) is
    My_Reader   : Aevents_Reader;
    Input       : File_Input;
  begin
    My_Reader.Aevents_List := A_List;
    My_Reader.Current_Tag := Null_Unbounded_String;
    Open(To_String(Xml_Filename), Input);
    My_Reader.Set_Feature(Validation_Feature,False);
    My_Reader.Parse(Input);
    Input.Close;
    if not My_Reader.OK then
       My_Reader.Aevents_List.Clear;
    end if;
    A_List := My_Reader.Aevents_List;
  end From_Xml;

end Table_Aevents;
